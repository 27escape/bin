#!/usr/bin/env perl
# PODNAME: td2pdf - convert a plaintasks file into a PDF
# ABSTRACT: convert a plaintasks file into a PDF, using markdown and my ct2 and regen scripts

=head1 NAME

td2pdf

=head1 SYNOPSIS

    > td2pdf ..options..

    to get full help use
    > td2pdf --help   

=head1 DESCRIPTION

convert a plaintasks file into a PDF, using markdown and my ct2 and regen scripts

=cut

#
# (c) kevin mulholland, moodfarm@cpan.org
# this code is released under the Perl Artistic License

use 5.10.0 ;
use strict ;
use warnings ;
use App::Basis ;
use Path::Tiny ;

my $started_color = 'steelblue' ; #teal' ;  # '#6fae7f' 

# -----------------------------------------------------------------------------

sub button {
    my ($state, $color, $text) = @_ ;

    return "<span style='font-weight:bold; border: 1px solid $color;font-size:50%;" .
        "border-radius:5px;" .
        "color: white;background-color: $color;'>&nbsp;$text&nbsp;</span>";
        # "border-radius:15px;" .
    # return "<a class='button $color $state'>$text</a>";
}

# -----------------------------------------------------------------------------

sub badge {
    my ( $text, $color) = @_ ;
    return "{{.badge subject='TASK' status='$text' color='$color' size='60'}} " ;
}

my $TASK = badge( '&nbsp;&nbsp;', 'gray') ;
my $DONE = badge( '✔', 'green') ; # ✓
my $AXE = badge( '✘', 'red',);
my $STARTED = badge( '>', $started_color,);

my @task_states = qw(done started lasted tostart toend critical high low due created cancelled duration) ;
my $state_list = join( '|', @task_states) ;

# -----------------------------------------------------------------------------
# main

my $program = get_program() ;

my %opt = init_app(
    help_text =>
        "convert a plaintasks file into a PDF, using markdown and my ct2 and regen scripts",
    help_cmdline => "plaintasks_file",
    options      => {
        'clean|c'   => 'Force a clean build of the PDF',
        },
    #log_file => "your-logfile",
) ;

my $td = $ARGV[0] ;
show_usage("You need to pass a filename") if ( !$td ) ;
$td = fix_filename($td) ;
show_usage("You need to pass a valid filename") if ( !-f $td ) ;

my $outfile = $td ;
$outfile =~ s/\.td$/.md/i ;
$outfile =~ s/\.md$/-project.md/ if( $outfile !~ /-project/) ;

my $data = path($td)->slurp_utf8() ;

my $outdata = "" ;

# ordering of replacements is important!
foreach my $line ( split( /\n/, $data ) ) {
    $line =~ s|^(#)+ |$1# | ;
    $line =~ s|^(\w.*?):|## $1| ;
    $line =~ s|^:(\w+) |$1: | ;
    # replace standard bullets with gray ones
    $line
        =~ s|^\*\s+(.*)|* <span style='color:gray;font-style:italic'>$1</span>|
        ;

    # this is a bit sketchy and a mess, but if the line has an @started in it then we
    # will modify any [ ] entry, unless there is a value inside that 
    if( $line =~ m|\[ \].*?\@started|) {
        $line =~ s|\[ \]|[>]| ;             # pretend we have a new symbol for started
    }

    $line =~ s|^\[ \]\s+(.*)|* $TASK <span style='color:black'>$1</span>| ;
    $line =~ s!^\[(x|\+)\]\s+(.*)!* $DONE <span style='color:green'>$2</span>! ;
    # $line =~ s|^\[+\]\s+(.*)|* $DONE <span style='color:green'>$1</span>| ;
    $line =~ s|^\[>+\]\s+(.*)|* $STARTED <span style='color:$started_color'>$1</span>| ;
    $line
        =~ s|^\[-\]\s+(.*)|* $AXE <span style='color:#ff3300;text-decoration: line-through;'>$1</span>|
        ;

# this is crap coding, but I cannot quickly figure out how to accomodate an empty $1
    $line
        =~ s|^(\s+)\*\s+(.*)|$1* <span style='color:gray;font-style:italic'>$2</span>|
        ;

    $line =~ s|^(\s+)\[ \]\s+(.*)|$1* $TASK <span style='color:black'>$2</span>| ;
    $line =~ s!^(\s+)\[(x|\+)\]\s+(.*)!$1* $DONE <span style='color:green'>$3</span>! ;
    # $line =~ s|^(\s+)\[+\]\s+(.*)|$1* $DONE <span style='color:green'>$2</span>| ;
    $line =~ s|^(\s+)\[>\]\s+(.*)|$1* $STARTED <span style='color:$started_color'>$2</span>| ;
    $line
        =~ s|^(\s+)\[-\]\s+(.*)|$1* $AXE <span style='color:#ff3300;text-decoration: line-through;'>$2</span>|
        ;

    $line =~ s|(\(\d+[dwm]\))|**$1**|g ;
    # reformat the done/start etc notes
    $line =~ s/\@($state_list)\s?\((\d{4}-\d{2}-\d{2})\)/[$1: $2]/g ;
    # lasted and due are durations
    $line =~ s/\@(lasted|due|duration)\s?\((.*?)\)/[duration: $2]/g ;

    # $line =~ s/\@(done|started|lasted|tostart)\s?\(/$1(/g ;
    $line
        =~ s|(\@\w+)|<span style='border: 1px solid goldenrod;background-color:cornsilk;font-size:75%;'>&nbsp;$1 &nbsp;</span>|g
        ;

    $outdata .= "$line\n" ;
}

path($outfile)->spew_utf8($outdata) ;
my $clean = $opt{clean} ? "-c" : "" ;
my ( $code, $out, $err ) = run_cmd("regen $clean '$outfile'") ;
print $out ;        # $out will already have a LF at the end
if ($err) {
    say "$err - check $outfile" ;
} else {
    # remove the intermediate markdown file
    unlink $outfile ;
}

