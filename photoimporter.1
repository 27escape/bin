#!/usr/bin/env perl
# PODNAME: photoimporter - import photos from usb or SD card
# ABSTRACT: import photos from usb or SD card

=head1 NAME

photoimporter

=head1 SYNOPSIS

    > photoimporter ..options..

    to get full help use
    > photoimporter --help   

=head1 DESCRIPTION

This must be run in a terminal under X windows, it expects that your OS will automount
a USB drive or SD card to some directory under /media/$LOGIN/

=cut

#
# (c) Kevin Mulholland, moodfarm@cpan.org
# this code is released under the Perl Artistic License

use 5.10.0;
use strict;
use warnings;
use App::Basis;
use Path::Tiny;
use File::ChangeNotify;
# use Device::BlinkStick;
use Data::Printer;
use Image::ExifTool qw(:Public);
use Imager::ExifOrientation;
use Furl ;


sub process_dir {
    my ($dir, $target, $upload) = @_ ;

    my $iter = path( $dir)->iterator( recurse => 1) ;

    # find all the JPG files, check if we have them already, otherwise process
    # them
    while ( $path = $iter->() ) {
            next if ( $path>path() !~ /\.(jpe?g|png)$/i );

            my $file = $path->basename() ;

            # now for the copy
            my $dest = "$target/$file";
            if ( !-f $dest ) {
                if ( !-d $target ) {
                    path($target)->mkpath;
                    if ( !-d $target ) {
                        say STDERR "Could not create destination dir $target";
                        next;
                    }
                }
                path( $file->path() )->copy($dest);

                my $exif = ImageInfo($dest);
                if (   $dest =~ /\.jpe?g$/i
                    && $exif->{Orientation}
                    && $exif->{Orientation} !~ /horizontal/i ) {

                    # my $img = Imager->new(file => $filename) ;
                    # Imager::ExifOrientation
                    my $image = Imager::ExifOrientation->rotate( path => $dest );
                    # we will keep the original and save the a new rotated file

                    $dest =~ s/(\.jpe?g$)/_rot$1/i;
                    # $image->write( file => $dest, jpegquality => 90 );
                    $exif = ImageInfo($dest);
                }

                # and print it

                my $md = "title: $dest
template: polaroid
format: pdf


~~~~{ .polaroid src='$dest' }
~~~~ 
";
                my $md_file = $dest;
                $md_file =~ s/\.jpe?g$/.md/i;
                path($md_file)->spew_utf8($md);

                my $pdf = $dest;
                $pdf =~ s/\.jpe?g$/.pdf/i;

                my $cmd = "ct2 -p $md_file -o $pdf &";
                say "running $cmd" ;
                # system($cmd);

                if( $upload) {

                }

    }

}


# -----------------------------------------------------------------------------
# main

my $program = get_program();

my %opt = init_app(
    help_text    => "Import photos",
    help_cmdline => "",
    options      => {
        'verbose|v' => 'Dump extra useful information',
        'dest|d=s' => { desc => 'Destination to copy photo files to', required => 1 },
        'upload|u' => 'Upload to the wedding website'
    },
);

$opt{dest} = fix_filename( $opt{dest} );
path( $opt{dest} )->mkpath;

msg_exit( "Could not create $opt{dest}", 2 ) if ( !-d $opt{dest} );

if ( $opt{verbose} ) {
    debug( "INFO", "Started" );
}


my $user = getlogin || getpwuid($<);
my $watchdir = "/media/$user";
my $file
    = File::ChangeNotify->instantiate_watcher( directories => $watchdir );
# my $stick = Device::BlinkStick->new();

while (1) {
    # $stick->set_color('darkgreen');
    # now we can check if the file/dir has changed
    my @changed = $file->wait_for_events();
    # $stick->set_color('maroon');

    if ( scalar(@changed) ) {
        my $count = 0;
        foreach my $file (@changed) {
            # the first thing that should be here is the media dir name
            # lets check if this is one of our photo media devices and dump things if not
            if ( !$count++ ) {
                if ( !-f $file->path() . "/.photo" ) {
                    say $file->path() . " does not have .photo";
                    last;
                }
            }

# we only want to know when things have been created (due to the filesystem coming online)
            next if ( $file->type() ne 'create' || !-f $file->path() );

            # if we stringify we know we have a unix style path
            my @parts = split( '/', path( $file->path() )->stringify() );
            next if ( $parts[4] ne 'DCIM' );

            next if ( $file->path() !~ /\.(jpe?g|png)$/i );

            # now for the copy
            my $dest = "$opt{dest}/" . join( '/', @parts[ 5, -1 ] );
            if ( !-f $dest ) {
                # flicker color while copying
                my $colors = ( $count & 1 ) ? 'darkorange' : 'orangered';
                # $stick->set_color($colors);
                my $dir = path($dest)->dirname;
                if ( !-d $dir ) {
                    path($dir)->mkpath;
                    if ( !-d $dir ) {
                        say STDERR "Could not create destination dir $dir";
                        next;
                    }
                }
                path( $file->path() )->copy($dest);

                my $exif = ImageInfo($dest);
                if (   $dest =~ /\.jpe?g$/i
                    && $exif->{Orientation}
                    && $exif->{Orientation} !~ /horizontal/i ) {

                    # my $img = Imager->new(file => $filename) ;
                    # Imager::ExifOrientation
                    my $image = Imager::ExifOrientation->rotate( path => $dest );
                    # we will keep the original and save the a new rotated file

                    $dest =~ s/(\.jpe?g$)/_rot$1/i;
                    # $image->write( file => $dest, jpegquality => 90 );
                    $exif = ImageInfo($dest);
                }

                # and print it

                my $md = "title: $dest
template: polaroid
format: pdf


~~~~{ .polaroid src='$dest' }
~~~~ 
";
                my $md_file = $dest;
                $md_file =~ s/\.jpe?g$/.md/i;
                path($md_file)->spew_utf8($md);

                my $pdf = $dest;
                $pdf =~ s/\.jpe?g$/.pdf/i;

                my $cmd = "ct2 -p $md_file -o $pdf &";
                say "running $cmd" ;
                # system($cmd);

                if( $opt{upload}) {

                }

                # back to red when completed
                # $stick->set_color('maroon');
            }
        }
    }
    else {
        debug( "INFO", "something happend but no changes found" );
    }
    # $stick->set_color('black');
}
