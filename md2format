#!/usr/bin/env perl
#!/usr/bin/perl

=head1 NAME

markup

=head1 DESCRIPTION

Convert my modified version of markdown into various document formats

this will create a ~/.markup directory and add some files to it

=head1 AUTHOR

 kevin mulholland, moodfarm@cpan.org

=cut

use v5.14;
use strict;
use warnings;
use Data::Printer;
use File::Slurp qw(read_file write_file);
use App::Basis;
use App::Basis::Config;
use POSIX qw(strftime);
use File::Basename qw(dirname);
use Try::Tiny;
use App::Basis::ConvertText;

# -----------------------------------------------------------------------------

my $MARKUP_DIR = "$ENV{HOME}/.markup";
$MARKUP_DIR = $ENV{MARKUP_DIR} if ( $ENV{MARKUP_DIR} );

my $CACHE_DIR = "/tmp/" . getpwuid($>) . "/cache";

my $HTML_HEADER = <<EOD;
<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01//EN' 'http://www.w3.org/TR/html4/strict.dtd'>
<html>
    <head>
        <title>%TITLE%</title>
        <meta name="Created" content="%DATE%" />
        <meta name="Author" content="%AUTHOR%" />
        <meta name="Copyright" content="%COPYRIGHT%" />
        <meta name="summary" content="%SUMMARY%" />
        <meta name="keywords" content="%KEYWORDS%" />
        <meta name="revision" content="%REVISION%" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

        <style type='text/css'>
            \@page { 
                size: %PAGE_SIZE% %ORIENTATION% ; 
                margin: 90pt 30pt 40pt 30pt ;
                \@top { 
                    margin: -10pt 0pt 0pt -90pt ;
                }
                \@bottom-right { content: counter(page) ;}
            }            }
            body {font-style: sans-serif;}
            /* toc */
            #toc { 
              padding: 0.4em;
              page-break-after: always;
            }
            #toc p {
                color: #4f81bd; 
                font-weight: bold;
                font-size: 32;
            }
            #toc h3 {
              text-align: center
            }
            #toc ul {
              columns: 1;
            }
            #toc ul, #toc li {
              list-style: none;
              margin: 0;
              padding: 0;
              padding-left: 10px ;
            }
            #toc a::after {
              content: leader('.') target-counter(attr(href), page);
              font-style: normal;
            }
            #toc a {
                text-decoration: none ;
                color: black;
            }

            /* tables*/
            table { page-break-inside: avoid ;}
            table.md { 
                border: 1px black solid; 
                border-collapse: collapse;
                border-spacing: 0px;
                padding-bottom:20px;
            }
            table.md th {
                background-color:yellowgreen; 
                font-weight: bold;
                border: 1px black solid;
            }
            table.md tr { valign:top;}
            table.md tr.odd { background-color: white;}
            table.md tr.even {background-color: #F0FFF0;}
            table.md td {
                border: 1px black solid; 
                padding-left:10px;
                padding-right:10px;
            }

            table.footer { font-size: 10px; width: 100%;}
            table.footer td.commercial { 
                font-weight: bold; 
                font-size: 12px;
                text-align: center;
            }
            /* nice markup for source code */
            table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
                margin: 0; padding: 0; vertical-align: baseline; border: none; 
            }
            table.sourceCode { width: 100%; line-height: 100%; }
            td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
            td.sourceCode { padding-left: 5px; }
            code > span.kw { color: #007020; font-weight: bold; }
            code > span.dt { color: #902000; }
            code > span.dv { color: #40a070; }
            code > span.bn { color: #40a070; }
            code > span.fl { color: #40a070; }
            code > span.ch { color: #4070a0; }
            code > span.st { color: #4070a0; }
            code > span.co { color: #60a0b0; font-style: italic; }
            code > span.ot { color: #007020; }
            code > span.al { color: #ff0000; font-weight: bold; }
            code > span.fu { color: #06287e; }
            code > span.er { color: #ff0000; font-weight: bold; }

        </style>
    </head>
    <body>

    <!-- remove this if you do not need a Table of Contents -->
     <div id='toc' >
        %TOC%
    </div>
EOD

my $HTML_FOOTER = <<EOD;
        <table class='footer' width='100%'>
            <tr><td>(c) %COPYRIGHT%</td><td align='right'>%DATE%</td>
        </table>
    </body>
</html>
EOD

my $CSS = <<EOD;

EOD

# -----------------------------------------------------------------------------

sub other_debug {
    my ( $state, $debug ) = @_;
    # return if ( $state ne 'DEBUG' );

    my $msg = $state;
    $msg .= " $debug" if ($debug);

    say STDERR localtime() . " " . get_program() . " $msg" ;
}

# -----------------------------------------------------------------------------

sub create_defaults {
    my $dir     = shift;
    my $verbose = shift;

    die "dir option required" if ( !$dir );

    if ( !-d $dir ) {
        say "Creating $dir" if ($verbose);
        my ( $r, $o, $e ) = run_cmd("mkdir -p $dir");
        msg_exit("Could not create $dir") if ($r);

    }
    # create the defaults if they do not exist
    my $default = "$dir/styles/default";
    my ( $r, $o, $e );
    ( $r, $o, $e ) = run_cmd("mkdir -p $default");
    msg_exit("Could not create default styles dir in $dir") if ($r);

    # create header and footers
   write_file( "$default/header.html", {binmode => ':utf8'}, $HTML_HEADER ) if ( !-f "$default/header.html" );
   write_file( "$default/footer.html", {binmode => ':utf8'}, $HTML_FOOTER ) if ( !-f "$default/footer.html" );
    # write_file( "$default/header.html", $HTML_HEADER ) if ( !-f "$default/header.html" );
    # write_file( "$default/footer.html", $HTML_FOOTER ) if ( !-f "$default/footer.html" );

    my $config = App::Basis::Config->new( filename => "$default/config" );
    # if there is no data in the config then lets create some
    if ( !$config->has_data() ) {
        $config->set( '/page/size',        'A4' );
        $config->set( '/page/orientation', 'Portrait' );
        my $author = getpwuid($>);
        $config->set( '/author',    $author );
        $config->set( '/copyright', "Property of $author 2013" );
        $config->store();
    }
}

# -----------------------------------------------------------------------------

sub read_settings {
    my ( $style, $dir ) = @_;
    my %settings;

    die "dir option required" if ( !$dir );

    $style ||= 'default';
    $style =~ s/\v//g;
    my $styledir = "$dir/styles/$style";
    if ( !-d $styledir ) {
        debug( "INFO", "Style '$style' does not exist, using default" );
        $styledir = "$dir/styles/default";
    }
    $settings{config} = App::Basis::Config->new( filename => "$styledir/config" );

    $settings{style}       = $style;
    $settings{style_dir}   = $styledir;
    $settings{html_header} = read_file("$styledir/header.html", binmode => ':utf8' );
    $settings{html_footer} = read_file("$styledir/footer.html", binmode => ':utf8' );
    # $settings{html_header} = read_file("$styledir/header.html"  );
    # $settings{html_footer} = read_file("$styledir/footer.html" );

    return \%settings;
}

# -----------------------------------------------------------------------------
# main

my %opt = init_app(
    help_text => "Convert my modified markdown text files into other formats, by default will 
  create HTML in same directory as the input file, will only process .md files.
If there is no output option used the output will be to file of same name as input filename but
with an extension (if provided) from the document, use :format keyword (pdf html doc).",
    options => {
        'verbose|v'    => 'verbose mode',
        'filename|f=s' => {
            desc => 'filename to convert',
            # required => 1,
            # validate => sub { my $file = shift; $file =~ s/^~/$ENV{HOME}/; -f $file && $file =~ /\.md$/i },
        },
        'clean|c'    => 'Clean up the cache before use',
        'style|s=s'  => 'name of style to use',
        'embed|e'    => 'Embed images into HTML, do not use this if converting to doc/odt or pdf via libreoffice',
        'prince|p'   => 'Convert to PDF using prince rather than libreoffice, can handle embedded images',
        'output|o=s' => {
            desc    => 'Filename to store the output as, extension will control conversion',
            default => "",
        }
    }
);

set_debug( \&other_debug ) if( $opt{verbose});

$opt{config_dir} ||= $MARKUP_DIR;
create_defaults( $opt{config_dir} );

show_usage("option filename is required, must be .md") if ( !$opt{filename} );
# show_usage("option output is required") if ( !$opt{output} );

$opt{filename} =~ s/^~/$ENV{HOME}/;
if ( $opt{filename} ne '-' && !( -f $opt{filename} && $opt{filename} =~ /\.md$/i ) ) {
    show_usage("option filename must be .mu or .md");
}

my $story ;
if( $opt{filename} eq '-') {
    $story = do { local $/; <STDIN> };
    } else {
   $story = read_file( $opt{filename}, binmode => ':utf8'  );
    # $story = read_file( $opt{filename}  );
}

show_usage("Bad markup file $opt{filename}") if ( !$story );

# anything in the replace hash will get replaced in the final document
my $replace = {
    # '%TITLE%'   => '',    # this comes from the first markdown level 1 header
    # '%DATE%' => strftime( "%Y-%m-%d", gmtime() ),    # :date in document overrides
    # '%COPYRIGHT%'   => $settings->{config}->get("copyright")        || '',    # :copyright in document overrides
    # '%AUTHOR%'      => $settings->{config}->get("author")           || '',    # :author in document overrides
    # '%PAGE_SIZE%'   => $settings->{config}->get("page/size")        || '',
    # '%ORIENTATION%' => $settings->{config}->get("page/orientation") || '',
    # '%KEYWORDS%' => '',   # get from document :keywords or :tags
    # '%SUMMARY%' => '',   # get from document :summary
    # '%REVISION%' => '',   # get from document :revision
};

# get any style from the stop of the story
my $settings;
my ($style) = ( $story =~ /^:style\s+(.*?)$/sm );

# document style overwritten by the command line option
$style = $opt{style} if ( $opt{style} );

# now lets find out if there is a special per dir config for style
my $dircfg = dirname( $opt{filename} ) . "/.markup";
# obviously command line style over-rides
if ( -f $dircfg && !$style ) {
    my $cfg = App::Basis::Config->new( filename => $dircfg );
    # if we have some style, then we need to re-load the settings
    if ( $cfg->get('style') ) {
        $settings = read_settings( $cfg->get('style'), $opt{config_dir} );
    }
    # we may want to over-ride the style settings with some local values
    foreach my $field (qw( copyright author)) {
        my $val = $settings->{config}->get($field);
        $settings->{config}->set( $field, $val ) if ($val);
    }
}
else {
    $settings = read_settings( $style, $opt{config_dir} );
}

# add in style defaults if needed
$replace->{'%DATE%'} ||= strftime( "%Y-%m-%d", gmtime() );
$replace->{'%COPYRIGHT%'}   ||= $settings->{config}->get("copyright");
$replace->{'%AUTHOR%'}      ||= $settings->{config}->get("author");
$replace->{'%PAGE_SIZE%'}   ||= $settings->{config}->get("page/size");
$replace->{'%ORIENTATION%'} ||= $settings->{config}->get("page/orientation");

my $format = App::Basis::ConvertText->new(
    name        => get_program(),
    use_cache   => 1,
    cache_dir   => $CACHE_DIR,
    html_header => $settings->{html_header},
    html_footer => $settings->{html_footer},
    replace     => $replace,
    verbose     => $opt{verbose},
    embed       => $opt{embed},
);
$format->clean_cache() if ( $opt{clean} );

my $data = $format->parse($story);

# decide on output filename from any format keyword
my $keywords = $format->keywords;
if ( !$opt{output} && $keywords->{format} ) {
    # same name as input
    $opt{output} = $opt{filename};
    # change extension
    $opt{output} =~ s/\.md$/.$keywords->{format}/i;
}

if ( $opt{output} ) {
    my $status = $format->save_to_file( $opt{output}, $opt{prince} );

    if ( $opt{verbose} && $status ) {
        say "Created $opt{output}";
    }
    elsif ( !$status ) {
        say "Failed to create $opt{output}";
    }
}
else {
    say STDERR "Ignoring $opt{filename}, could not determine a filename to output to, no :format option in file?" if( $opt{verbose});
}
