#!/usr/bin/env perl
# report on simple recordings
#
# (c) kevin Mulholland 2013, moodfarm@cpan.org
# this code is released under the Perl Artistic License

# v0.1 moodfarm@cpan.org, initial work

use 5.16.0;
use strict;
use warnings;
use App::Basis;
use Data::Printer;
use Try::Tiny;
use POSIX qw(strftime);
use Date::Manip ;
use JSON::Tiny ;
# this is our db schema and stuff
use Record::Schema;

# -----------------------------------------------------------------------------

my $DEFAULT_DB = '~/git/data/general_db.sqlite3';
my $DB_TABLE   = 'Record';

my @bucket_list = qw/date year month week day hour/;

my $debug_lvl = 0;

# -----------------------------------------------------------------------------

sub other_debug {
    my $debug = shift;
    say localtime() . " " . get_program() . " " . $debug if ($debug_lvl);
}

# -----------------------------------------------------------------------------

sub create_table_if_not_exists {
    my ( $schema, $table ) = @_;
    # check if we have data in the table, an exception will mean no table hopefully
    try {
        # attempt to read a single result from the table
        my $rs = $schema->resultset($table)->search( {}, { rows => 1 } )->single();
    }
    catch {
        # create the table from our schema as we think it does not exist
        $schema->deploy;
    };
}

# -----------------------------------------------------------------------------

sub create_datetime {
    my $datestr = shift ;
    my $date = new Date::Manip::Date;
    $date->parse( $datestr );
    my $day;
    {
        # if we get a warning about converting the date to a day, there
        # must be a problem with parsing the input date string
        local $SIG{__WARN__} = sub {
            die "Invalid date ($datestr)";
        };
        $day = $date->printf("%a");
    }
    my $d = $date->printf("%Y-%m-%d");
    my $t = $date->printf("%T");

    return "$d $t" ;
}

# -----------------------------------------------------------------------------
# main

my $program = get_program();

my %opt = init_app(
    help_text => "Query the data in our simple recording system, produce CSV output

$program --period='2012-01-01,2013-12-12' --buckets='hour'",
    help_cmdline => "name_of_thing",
    options      => {
        'verbose|v' => 'Dump extra useful information',
        'db=s'      => {
            desc    => 'SQLite DB to use',
            default => $DEFAULT_DB,
        },
        'period|p=s' => {
            default => "1970-01-01 00:00:00," . strftime( "%Y-%m-%d %H:%M:%S", localtime( time() ) ),
            desc    => 'date range to query',
            validate => sub { my $val = shift ; return $val =~ /,/;}
        },
        'buckets|b=s' => {
            desc    => 'group the data into datetime buckets from ' . join( ', ', @bucket_list ),
            default => $bucket_list[0],
            validate => sub { my $val = shift; return scalar( grep( /$val/i, @bucket_list ) ); }
        },
        'debug=i' => { desc => 'level of debugging required', default => 0 },
    }
);

$debug_lvl = $opt{debug};
set_debug( \&other_debug );

if ( $opt{verbose} ) {
    my $prog = get_program();
    debug("prog is '$prog'");
}

my ($thing) = @ARGV;
show_usage("Missing thing to query against") if ( !$thing );

$opt{db} =~ s/^~/$ENV{HOME}/;

my $schema = Record::Schema->connect("DBI:SQLite:$opt{db}");

show_usage("Invalid DB file") if ( !$schema );

# check if there is the correct table and create if needed
create_table_if_not_exists( $schema, $DB_TABLE );

try {
    my ( $from, $to ) = split( /,/, $opt{period});

    $from = create_datetime( $from) ;
    $to = create_datetime( $to) ;

    # reporting
    # should output CSV data
    # period = dates between
    #     date grouping by year / month / week / day / hour time slots
    # sum total value of things
    # sum total of things happening grouped buckets
    # count of things happpening in grouped buckets
    # all things

    # because we have already linked the Record and Tag classes, we do
    # not need to do any special joins
    my $rs = $schema->resultset('Record')->search( 
        { 'item' => $thing, 'datetime' => { '>=' => $from, "<=" => $to } }, 
        { 
            # join => 'tags',
            # '+select' => ['tags.tag_name', 'tags.tag_value'],
            # '+as' => ['tag', 'tag_value']
        } );

    say join( ',',  qw(id datetime item value tags)) ; ;
    my $json  = JSON::Tiny->new;
    while (my $row = $rs->next) {
        my @tags ;
        print  join( ',',  $row->id, $row->datetime, $row->item, $row->value) . "," ;
        # get the linked tags, there are not many so we can just grab an array
        my @linked_tags = $row->tags ;
        foreach my $t ( @linked_tags) {
            push @tags, $t->tag_name . "=" . $t->tag_value ;
        }
        # as we are dumping to CSV we need to doublequote the doublequotes
        my $js = $json->encode( \@tags) ;
        $js =~ s/"/""/g ;
        say ( @tags ? '"' . $js . '"' : "") ; 
    }

}
catch {
    # log the actual issue for the developer
    debug($_);
    # remove the at line thing for user data
    s/at .*? line.*//;
    say "Error $_";
};






